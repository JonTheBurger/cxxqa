#pragma once

#include <cstdint>
#include <optional>
#include <string>
#include <string_view>

namespace cxxqa {

/** Parses diagnostics generated by GCC and like tools in the form
 * `test-labelled-ranges.c:9:6: error: mismatching types: 'int' and 'const char *'`.
 * @see https://gcc.gnu.org/wiki/libgdiagnostics
 */
struct Diagnostic {
  std::string file;     ///< File where the diagnostic originated (REQUIRED).
  uint32_t    line;     ///< Line number where the diagnostic originated (optional).
  uint32_t    column;   ///< Column number where the diagnostic originated (optional).
  std::string severity; ///< Severity of the diagnostic, such as "warning" or "error" (optional).
  std::string message;  ///< Message describing the diagnostic (REQUIRED).
  std::string category; ///< Rule that triggered the diagnostic. Typically a -Wwarning type (optional).
  std::string source;   ///< Additional context, generally showing textual a cursor pointing to the issue (optional).

  /** Parses a diagnostic from a string.
   * @param str String containing diagnostic in the form:
```
C:/Users/vagrant/My Documents/diagnostic.cpp:10:8: warning: variable ‘parse’ set but not used [-Wunused-but-set-variable]
   10 |   auto parse = Parser(str);
      |        ^~~~~
```
   */
  static auto from_string(std::string_view str) -> std::optional<Diagnostic>
  {
    return consume_from_string(str);
  }

  /** Parses a diagnostic from a string, shrinking the string to remove the parsed diagnostic.
   * @param str String containing diagnostic in the form:
```
C:/Users/vagrant/My Documents/diagnostic.cpp:10:8: warning: variable ‘parse’ set but not used [-Wunused-but-set-variable]
   10 |   auto parse = Parser(str);
      |        ^~~~~
```
   */
  static auto consume_from_string(std::string_view& str) -> std::optional<Diagnostic>;
};
}  // namespace cxxqa

#include <fmt/base.h>
template <>
struct fmt::formatter<cxxqa::Diagnostic> : formatter<std::string_view> {
  auto format(const cxxqa::Diagnostic& self, format_context& ctx) const -> format_context::iterator;
};
